/*
encoding.h: This code implements packed integer encoding

List of Authors:
Chiraag Juvekar, chiraag@mit.edu

License Information:
MIT License
Copyright (c) 2017, Massachusetts Institute of Technology (MIT)

*/

#ifndef LBCRYPTO_CRYPTO_FV_C
#define LBCRYPTO_CRYPTO_FV_C

#include <map>
#include <iostream>
#include <fstream>

#include "math/params.h"
#include "math/transfrm.h"

namespace lbcrypto {
    std::map<ui64, uv32> g_to_ftt_map;
    std::map<ui64, uv32> g_from_ftt_map;

    void encoding_precompute(const ui64& mod_p, const ui32& logn){
        ui32 phim = (1 << logn);
        ui32 phim_by_2 = phim/2;
        ui32 mask = phim*2-1;

        // Create the permutations that interchange the automorphism and crt ordering
        // First we create the cyclic group generated by 5 and then adjoin the co-factor by multiplying by 3
        uv32 to_ftt_perm(phim);
        uv32 from_ftt_perm(phim);

        ui32 curr_index = 1;
        for (ui32 i = 0; i < phim_by_2; i++) {
            to_ftt_perm[(curr_index - 1) / 2] = i;
            from_ftt_perm[i] = (curr_index - 1) / 2;

            ui32 cofactor_index = (curr_index * mask) & mask;
            to_ftt_perm[(cofactor_index - 1) / 2] = i + phim_by_2;
            from_ftt_perm[i + phim_by_2] = (cofactor_index - 1) / 2;

            curr_index = (curr_index * 5) & mask;
        }
        g_to_ftt_map[mod_p] = std::move(to_ftt_perm);
        g_from_ftt_map[mod_p] = std::move(from_ftt_perm);

        return;
    }

    uv64 packed_encode(const uv64& input, const ui64 mod_p, const ui32 logn){
        ui32 phim = (1<<logn);
        uv64 input_perm(phim);
        const auto& to_ftt_perm = g_to_ftt_map[mod_p];

        // Permute to CRT Order
        for (ui32 i = 0; i < phim; i++) {
            input_perm[i] = input[to_ftt_perm[i]];
        }
        if(mod_p == opt::p){
            input_perm = ftt_inv_opt_p(input_perm);
        } else {
            input_perm = ftt_inv(input_perm, mod_p, logn);
        }

        return input_perm;
    }

    uv64 packed_decode(const uv64& input, const ui64 mod_p, const ui32 logn){
        // Transform Coeff to Eval
        ui32 phim = (1<<logn);
        uv64 output_perm(phim), output_tr(phim);
        const auto& from_ftt_perm = g_from_ftt_map[mod_p];

        if(mod_p == opt::p){
            output_tr = ftt_fwd_opt_p(input);
        } else {
            output_tr = ftt_fwd(input, mod_p, logn);
        }
        // Permute to automorphism Order
        for (ui32 i = 0; i < phim; i++) {
            output_perm[i] = output_tr[from_ftt_perm[i]];
        }

        return output_perm;
    }

}  // namespace lbcrypto ends

#endif
